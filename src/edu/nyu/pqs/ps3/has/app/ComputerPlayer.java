/**
 * This code is submission of pqs Assignment4 to implement Connect Four
 *
 * @author  Himani Shah (has482)
 */
package edu.nyu.pqs.ps3.has.app;

import java.awt.*;

/**
 * The Computer player class is for the Computer players. The Computer player objects are create in this class .
 * The computer player has is own strategy to play. Some of the methods in the model and Computer Player class are repetitive,
 * this is because we only want Computer Player to have the grid state at a particular time and then play using its own winning logic,
 * rather than using models methods.
 */
    class ComputerPlayer implements Player {

    private Color color;
    private int playerId;
    private ConnectFourModel model;
    int grid[][];

    /**
     * Computer player constructor creates a computer player object with player id and disc color as parameters
     * @param playerId Autogenerated unique id for each player
     * @param color Autogenerated color for each player
     */
    ComputerPlayer(int playerId, Color color, ConnectFourModel model){
        this.playerId = playerId;
        this.color = color;
        this.model = model;
    }

    /**
     * Computers strategy for playing. The strategy is as follows:
     *
     * Computer gets the grid status from model.
     * It tries adding disc to each column(ones which are not full)
     * If any of the disc added results in a win, Computer makes that move
     * Or computer chooses a random move.
     */
    public void play() {
        grid = model.getInternalGrid().clone();  //get grid status from model
        for(int i=0; i< grid[0].length;i++){ //It tries adding disc to each column
            if(checkIfColumnFull(i)){  //checks if column is full
                break;
            }
            int row = addDiscGetRowPosition(i);  //corresponding row position for the disc added in the particular column

            if(checkIsWin()){//Checks if the move results in a win
                undoDiscAddition(row, i);
                model.makeMove(i);//notifies the model to make that move
                return;
            }
            else{
                undoDiscAddition(row, i);  //reset to original grid status
            }
        }
        model.makeMove(chooseRandomMove());  //makes a random move, if no move results in a win.
    }

    /**
     * Checks if a particular column in grid is full
     * @param column
     * @return
     */
    private boolean checkIfColumnFull(int column) {
        return grid[0][column] != -1;
    }

    /**
     * Checks if adding a disc to a column, results in a win. Need to check all the player positions in the grid to
     * handle the situation where the 3 discs are in a row with one missing space in between.
     *
     * @return True/False if the move would result in a win
     */
    boolean checkIsWin(){
        for (int j = 0; j < model.getGridNoOfRows(); j++) {
            for (int k = 0; k < model.getGridNoOfColumns(); k++) {
                if (isWin(j, k)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if players disc at a particular position in the grid results in a win.
     * We check vertiacally upwards, horizontally right, diagonally left upwards and diagonally right upwards.
     * We dont need to check for other scenarios as we check at each position in the grid.
     *
     * @param row row position
     * @param column column position
     * @return True/False, if disc in that position, results in a win.
     */
    public boolean isWin(int row, int column) {
        if (checkVertical(row, column)) return true;
        if (checkHorizontal(row, column)) return true;
        if (checkDiagonallyLeft(row, column)) return true;
        if (checkDiagonallyRight(row, column)) return true;
        return false;
    }

    /*
     * Checks vertically.
     */
    private boolean checkVertical(int row, int column) {
        if (row <= model.getGridNoOfRows()-model.getNeedToWin()) {
            for (int i = 0; i < model.getNeedToWin(); i++) {
                if (grid[row + i][column] != playerId) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    /*
     * Checks Horizontally.
     */
    private boolean checkHorizontal(int row, int column) {
        if (column <= model.getGridNoOfColumns()-model.getNeedToWin()) {
            for (int i = 0; i < model.getNeedToWin(); i++) {
                if (grid[row][column + i] != playerId) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    /*
     * Checks Diagonally Left.
     */
    private boolean checkDiagonallyLeft(int row, int column) {
        if ((row - (model.getNeedToWin()-1) >= 0) && (column - (model.getNeedToWin()-1) >= 0)) {
            for (int i = 0; i < model.getNeedToWin(); i++) {
                if (grid[row - i][column - i] != playerId) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    /*
     * Checks Diagonally Right.
     */
    private boolean checkDiagonallyRight(int row, int column) {
        if ((row - (model.getNeedToWin()-1) >= 0) && (column + (model.getNeedToWin()-1) <= model.getGridNoOfColumns()-1)) {
            for (int i = 0; i < model.getNeedToWin(); i++) {
                if (grid[row - i][column + i] != playerId) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    /*
     * reset to original grid status, before computer made a move
     */
     void undoDiscAddition(int row, int col) {
        if(row<0 || col<0 || row>=grid.length || col>=grid[0].length){
            throw new IllegalArgumentException("row and column values are incorrect");
        }
        grid[row][col] = -1;
    }

    /*
     * Add a Disc to a particular column and get the corresponding row position
     * @throws IllegalArgumentException if column position is out of range
     * @throws IllegalArgumentException if we try to add a disc in column that is full
     * @returns corresponding row position.
     */
    private int addDiscGetRowPosition(int column) {
        if(column<0 || column>=grid[0].length){
            throw new IllegalArgumentException("Column position out of range");
        }
        for (int row = grid.length-1; row >= 0; row--) {
            if (grid[row][column] == -1) {
                grid[row][column] = playerId;
                return row;
            }
        }
        throw new IllegalArgumentException("No space in this column");
    }

    /*
     * Generates a random column move. It makes sure that is does not choose a column that is already full
     *
     * @returns random column position
     */
    private int chooseRandomMove() {
        int randomCol = getRandomInteger(0,6);
        while(checkIfColumnFull(randomCol)) {
            randomCol = getRandomInteger(0,6);
        }
        return randomCol;
    }

    /**
     * Returns disc color used by the player
     */
    public Color getCoinColor() {
        return color;
    }

    /**
     * Returns players id
     */
    public int getPlayerId() {
        return playerId;
    }

    /**
     * Returns string with player details
     */
    @Override
    public String toString(){
        return "Computer Player";
    }

    /*
     * returns random integer within a range
     */
    private int getRandomInteger(int min, int max){
        int x = (int) (Math.random()*((max-min)+1)+min);
        return x;
    }

}
